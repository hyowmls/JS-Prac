// 변수
var, let, const를 사용해 변수를 선언할 수 있다.

let과 const를 주로 사용하고 var는 거의 사용하지 않는다.
let은 값을 변경할 수 있지만, const는 값을 변경할 수 없다.
const로 선언한 변수를 <상수> 라고 부른다.
    - 대문자 상수 : 기억하기 힘든 값을 변수에 할당할 때 사용한다.  //ex. RGB값 등

-----------------------------------------------------------------------
// 자료형
숫자형, 문자형, Boolean형, null, undefined, 객체형, 심볼형

숫자형 - 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용한다
문자형 - 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용한다
Boolean형 - true, false를 반환할 때 사용한다
null - null 값만을 위한 독립적인 자료형이다. 알 수 없는 값을 나타낸다
undefined - undefined 값만을 위한 독립적인 자료형이다. 할당되지 않은 값을 나타낸다
객체형 - 복잡한 데이터 구조를 표현할 때 사용한다
심볼형 - 객체의 고유 식별자를 만들때 사용한다

-----------------------------------------------------------------------
// 기본 연산자
단항, 이항, 피연산자, 증감-감소 연산자

피연산자(operand) - 연산자가 연산을 수행하는 대상. 피연산자는 '인수(argument)' 라고 불리기도 한다
단항(unary) - 피연산자를 하나만 받는 연산자
이항(binary) - 피연산자를 두 개를 받는 연산자
증감(increment) 연산자 - 변수를 1 증가시킴  //ex. let count = 1
                                            count++;     // count = 2
감소(decrement) 연산자 - 변수를 1 감소시킴  //ex. let count = 2
                                            count--;     // count = 1
    - 증감, 감소 연산자는 변수에만 사용할 수 있다.
    - 증감, 감소 연산자는 변수의 앞, 뒤에 사용할 수 있고 값을 반환하는 방식이 달라진다.
    // ex.
            let count = 1;
            let a = ++count;
            console.log(a) // 2
            - 전위형은 count를 증가시키고 값을 반환한다.

            let count = 1;
            let a = count++;
            console.log(a) // 1
            - 후위형은 count를 증가시키긴 하지만 기존의 값을 반환한다.

-----------------------------------------------------------------------
// 비교 연산자
문자열 비교 알고리즘 (사전순서)
    1. 두 글자의 첫 글자를 비교한다.
    2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료한다.
    3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
    4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
    5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.

일치 연산자 (===)
    엄격한 동등(==)연산자로 자료형의 동등 여부까지 검사한다.

* undefined 는 비교가 불가능하다.

-----------------------------------------------------------------------
// 논리 연산자
||(or), &&(and), !(not)

조건문에서 같이 쓰이곤 한다.

-----------------------------------------------------------------------
// 조건문
if () 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환
0, " ", null undefined, NaN은 불린형으로 변환 시 모두 false 
이 외의 값은 true

ex. if (0) {
        // 0은 false로 실행되지 않음
    }
    if (1) {
        // 1은 true로 항상 실행됨
    }

조건부 연산자 '?'
- 코드를 더 짧고 간결하게 만들어줌

ex. let result = (condition > 10 ) ? value1 : value2;
    - 평가 대상인 condition이 true라면 value1을 반환, false라면 value2를 반환
    - 괄호를 안써도 되지만 코드 가독성을 위해 사용하는 것을 권장

ex. let message = (age < 3) ? 'hello' : (age <18) ? 'hello_1' : (age < 100) ? 'hello_2' : '너무 높은 나이 입니다'
    - 중첩해서 사용 가능함

-----------------------------------------------------------------------
// switch문
복수의 if 조건문은 switch문으로 바꿀 수 있음
switch문은 하나 이상의 case문으로 구성됨

ex. switch(x){
        case 'value1':
            // 실행할 코드
            [break]
        case 'value2':
            // 실행할 코드
            [break]
        default:
            // 실행할 코드
            [break]
    }
변수의 x 값과 첫 번째 case문의 값 value1 과 일치 비교한 후, 두번째 와 비교함
case문에서 변수 x의 값과 일치하는 값을 찾으면 해당 case문의 코드가 실행됨. 이때, break문을 만나거나 switch문이 끝나면 코드 실행을 멈춤
값과 일치하는 case문이 없다면, default문의 코드가 실행됨

-----------------------------------------------------------------------
// 배열과 반복문
선언 예시
ex. let arr = new Array();
    let arr = [];

let fruits = ['사과', '오렌지', '배']
// 요소 수정(변경)
fruits[2] = '수박'

// 요소 추가
fruits[3] = '레몬'

배열 요소의 자료형에는 제약이 없음
ex. let arr = ['사과', {'name': 'bob'}, true, function(){'hello'}]
    alert('arr[1].name') // bob
    arr[3]();            // hello

큐(queue), 스택(stack)이라는 것도 있음
- 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용함
- 주요 연산
    arr.push(...items) - 맨 끝에 요소 추가
    arr.pop() - 맨 끝 요소 제거
    arr.shift() - 맨 앞 요소 제거
    arr.unshift(...itmes) - 맨 앞에 요소 추가


스택을 사용하면 가장 나중에 넣은 요소가 먼저 추출됨 - 후입선출
큐를 사용하면 먼저 넣은 요소가 먼저 추출됨 - 선입선출

<반복작업코드>
for (let i = 0; i < arr.length; i++ )
- 가장 빠른 방법이고 오래된 브라우저와도 호환가능

for (let item of arr)
- 배열 요소에만 사용되는 모던한 문법

// 메서드
splice - 추가, 삭제, 교체 모두가능
    arr.splice(index[ , deleteCount, elem1, ..., elemN])
    - 첫번째 매개변수는 조작을 할 요소를 가르키는 인덱스
    - 두번째 매개변수는 제거하고자 하는 요소의 개수
    - elem1, ..., elemN은 배열에 추가할 요소
    
    ex. let arr = ['I', 'study', 'Javscript']
        arr.splice(1,1) // 인덱스 1부터 요소 1개
                        // ['I', 'Javscript']

        let arr = ['I', 'study', 'Javscript', 'right', 'now']
        arr.splice(0, 3, "Let's", "dance") // 0부터 3개의 요소를 지우고, 이 자리를 다른 요소로 대체함
                                           // ["Let's"m, "dance", "right", "now"]
        
        let arr = ['I', 'study', 'Javscript']
        arr.splice(2, 0, 'complex', 'language') // 2부터 0개의 요소를 삭제하고 complex와 language를 추가함
                                                // ['I', 'study', 'complex', 'language', 'Javscript']

slice - start인덱스부터 end인덱스까지의 요소를 복사한 새로운 배열을 반환
    arr.slice(start,end)
    
    ex. let arr = ['t', 'e', 's', 't']
        arr.slice(1, 3) // e, s

concat - 기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가할 때 사용
    arr.concat(arg1, arg2)
    - 인수에는 배열이나 값이 올 수 있음
    - 메서드를 호출하면 arr에 속한 모든 요소와 arg1, arg2 등에 속한 모든 요소를 한데 모은 새로운 배열이 반환

// 배열 탐색하기

arr.indexOf(item, from)
- 인덱스 from부터 시작해 item을 찾음.
- 요소를 찾으면 해당 요소의 인덱스를 반환, 못찾으면 -1 반환

arr.lastIndexOf(itme, from)
- 위 메소드와 동일한 기능이지만 검색을 끝에서 부터 시작함

arr.includes(item, from)
- from부터 시작해 item이 있는지 검색을하고 요소를 발견하면 true를 반환
* 위 메서드 들은 요소를 찾을 때 완전 항등 연산자(===)를 사용함

arr.find(function)
- ex. let result = arr.find(function (item, index, array)) {
    // true가 반환되면 반복이 멈추고 해당 요소를 반환
    // 조건에 해당하는 요소가 없으면 undefined를 반환
}
    - item : 함수를 호출할 요소
    - index : 요소의 인덱스
    - array : 배열 자기 자신

- ex. let users = [
        {id : 1, name : "Kim"},
        {id : 2, name : "Lee"},
        {id : 3, name : "Park"}
    ]
    let user = users.find(item => item.id == 1)
    alert(user.name) // Kim

    - 실무에서 많이 자주 사용함
    - 202Line 패턴으로 자주 사용됨 index, array 인자들은 잘 사용하지 않음

// 배열 변형 메서드
map - 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환함
ex. let result = arr.map(function (item, index, array) {
    // 요소 대신 새로운 값 반환
})

ex. let lengths = ['Bilbo', 'Gandalf', 'Nazgul'].map(itme => item.length)
    alert(length)  // 5, 7, 6

* 메서드들은 검색해서 찾아 사용

// while 반복문
- 구조
while (condition) {
    // 코드
}
ex. let i = 0;
    while (i < 3) {
        alert(i)
        i++;
    }  // 0, 1, 2

// for 반복문
- 구조
for (begin; condition; step) {
    // 실행 코드
}
ex. for (let i = 0; i < 3; i++){
    alert(i) // 0, 1, 2
}

// 반복문 빠져나오기 - break
반복문은 false가 되면 종료되는데 특별한 지시자인 break를 사용하면 언제든 원하는 때에 반복문을 나올 수 있음
ex. let sum = 0;
    while (true) {
        let value = +prompt('숫자를 입력하세요', '');
        if (!value) break;
        sum += value;
    }

// 다음 반복으로 넘어가기 - continue
continue는 전체 반복을 멈추지 않고 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시킴
즉, 현재 반복을 종료하고 다음 반복으로 넘어가고 싶을 때 사용
ex. for (let i = 0; i < 10; i++) {
        if (i % 2 == 0) continue;
        alert(i); // 1,3,5,7,9
    }

// 레이블 - 여러 개의 중첩 반복문을 한번에 빠져나와야 할 때 사용
- 구조
labelName: for (...){

}
ex. outer: for (let i = 0; i < 3; i++) {
        for (let j = 0; j <3; j++) {
            let input = prompt(`(${i}, ${j})의 값`,'')
            if (!input) break outer;
        }
    }